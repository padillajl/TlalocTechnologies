/** ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename    : FSSH1.c
**     Project     : ProcessorExpert
**     Processor   : MKL25Z128VLK4
**     Component   : FSShell
**     Version     : Component 01.226, Driver 01.00, CPU db: 3.00.000
**     Compiler    : GNU C Compiler
**     Date/Time   : 2012-12-29, 14:29, # CodeGen: 232
**     Abstract    :
**
**     Settings    :
**
**     Contents    :
**         PrintPrompt        - void FSSH1_PrintPrompt(FSSH1_ConstStdIOType *io);
**         SendNum8u          - void FSSH1_SendNum8u(byte val, FSSH1_StdIO_OutErr_FctType io);
**         SendNum8s          - void FSSH1_SendNum8s(signed char val, FSSH1_StdIO_OutErr_FctType io);
**         SendNum16u         - void FSSH1_SendNum16u(word val, FSSH1_StdIO_OutErr_FctType io);
**         SendNum16s         - void FSSH1_SendNum16s(int16_t val, FSSH1_StdIO_OutErr_FctType io);
**         SendNum32u         - void FSSH1_SendNum32u(dword val, FSSH1_StdIO_OutErr_FctType io);
**         SendNum32s         - void FSSH1_SendNum32s(long val, FSSH1_StdIO_OutErr_FctType io);
**         SendStr            - void FSSH1_SendStr(const byte *str, FSSH1_StdIO_OutErr_FctType io);
**         Date               - byte FSSH1_Date(const unsigned char *cmd, FSSH1_ConstStdIOType *io);
**         Time               - byte FSSH1_Time(const unsigned char *cmd, FSSH1_ConstStdIOType *io);
**         PrintStatus        - byte FSSH1_PrintStatus(FSSH1_ConstStdIOType *io);
**         ShellCmd           - byte FSSH1_ShellCmd(const unsigned char *cmd, bool *handled,...
**         ReadLine           - bool FSSH1_ReadLine(byte *buf, size_t bufSize, FSSH1_ConstStdIOType *io);
**         PrintCommandFailed - void FSSH1_PrintCommandFailed(const unsigned char *cmd, FSSH1_ConstStdIOType...
**         ParseCommand       - byte FSSH1_ParseCommand(const unsigned char *cmd, FSSH1_ConstStdIOType *io,...
**         GetStdio           - FSSH1_ConstStdIOTypePtr FSSH1_GetStdio(void);
**         ReadAndParseLine   - byte FSSH1_ReadAndParseLine(byte *cmdBuf, size_t cmdBufSize,...
**         RequestSerial      - void FSSH1_RequestSerial(void);
**         ReleaseSerial      - void FSSH1_ReleaseSerial(void);
**         GetSemaphore       - void* FSSH1_GetSemaphore(void);
**         SendStatusStr      - void FSSH1_SendStatusStr(const byte *strItem, const byte *strStatus,...
**         SendHelpStr        - void FSSH1_SendHelpStr(const byte *strCmd, const byte *strHelp,...
**         ReadChar           - void FSSH1_ReadChar(byte *c);
**         SendChar           - void FSSH1_SendChar(byte ch);
**         KeyPressed         - bool FSSH1_KeyPressed(void);
**         Init               - void FSSH1_Init(void);
**         Deinit             - void FSSH1_Deinit(void);
**
**     License   :  Open Source (LGPL)
**     Copyright : (c) Copyright Erich Styger, 2012, all rights reserved.
**     This an open source software implementing a shell using Processor Expert.
**     Main purpose is for a file system, but useful as well without one.
**     This is a free software and is opened for education,  research  and commercial developments under license policy of following terms:
**     * This is a free software and there is NO WARRANTY.
**     * No restriction on use. You can use, modify and redistribute it for personal, non-profit or commercial product UNDER YOUR RESPONSIBILITY.
**     * Redistributions of source code must retain the above copyright notice.
** ###################################################################*/

/* MODULE FSSH1. */

#include "FSSH1.h"

#include <stdio.h>

#ifdef __HC08__
  #pragma MESSAGE DISABLE C3303 /* implicit concatenation of strings */
#endif
static LDD_TDeviceData *serialHandle = NULL; /* handle to device data */
static uint8_t charBuf; /* single character buffer for LDD ReceiveBlock() */
static volatile uint8_t FSSH1_SentFlag = 0; /* this will be set to 1 once the block has been sent */

static byte AddSWRTCDate(byte *buf, word bufSize)
{
  DATEREC date;

  if (TmDt1_GetDate(&date)!=ERR_OK) {
    return ERR_FAILED;
  }
  UTIL1_strcatNum16uFormatted(buf, bufSize, date.Day, '0', 2);
  UTIL1_chcat(buf, bufSize, '.');
  UTIL1_strcatNum16uFormatted(buf, bufSize, date.Month, '0', 2);
  UTIL1_chcat(buf, bufSize, '.');
  UTIL1_strcatNum16u(buf, bufSize, date.Year);
  return ERR_OK;
}

static byte AddSWRTCTime(byte *buf, word bufSize)
{
  TIMEREC time;

  if (TmDt1_GetTime(&time)!=ERR_OK) {
    return ERR_FAILED;
  }
  UTIL1_strcatNum16sFormatted(buf, bufSize, time.Hour, '0', 2);
  UTIL1_chcat(buf, bufSize, ':');
  UTIL1_strcatNum16sFormatted(buf, bufSize, time.Min, '0', 2);
  UTIL1_chcat(buf, bufSize, ':');
  UTIL1_strcatNum16sFormatted(buf, bufSize, time.Sec, '0', 2);
  UTIL1_chcat(buf, bufSize, ',');
  UTIL1_strcatNum16sFormatted(buf, bufSize, time.Sec100, '0', 2);
  return ERR_OK;
}


/* Internal method prototypes */
static void SendSeparatedStrings(const byte *strA, const byte *strB, byte tabChar, byte tabPos, FSSH1_StdIO_OutErr_FctType io);

/*
** ===================================================================
**     Method      :  FSSH1_SendStr (component FSShell)
**
**     Description :
**         Prints a string using an I/O function
**     Parameters  :
**         NAME            - DESCRIPTION
**         str             - String (zero terminated) to be printed.
**         io              - I/O callbacks to be used for printing.
**     Returns     : Nothing
** ===================================================================
*/
/*!
 * \brief Prints a string using I/O callbacks
 * \param[in] str String (zero terminated) to be printed
 * \param[in] io I/O function to be used for printing
 */
void FSSH1_SendStr(const byte *str, FSSH1_StdIO_OutErr_FctType io)
{
  while(*str!='\0') {
    io(*str++);
  }
}

/*
** ===================================================================
**     Method      :  FSSH1_SendNum32s (component FSShell)
**
**     Description :
**         Sends a 32bit signed number to the given I/O
**     Parameters  :
**         NAME            - DESCRIPTION
**         val             - number to print
**         io              - I/O callbacks to be used for printing.
**     Returns     : Nothing
** ===================================================================
*/
void FSSH1_SendNum32s(long val, FSSH1_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("-1234567890")];

  UTIL1_Num32sToStr(buf, sizeof(buf), val);
  FSSH1_SendStr(buf, io);
}

/*
** ===================================================================
**     Method      :  FSSH1_SendNum32u (component FSShell)
**
**     Description :
**         Sends a 32bit unsigned number to the given I/O
**     Parameters  :
**         NAME            - DESCRIPTION
**         val             - number to print
**         io              - I/O callbacks to be used for printing.
**     Returns     : Nothing
** ===================================================================
*/
void FSSH1_SendNum32u(dword val, FSSH1_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("1234567890")];

  UTIL1_Num32uToStr(buf, sizeof(buf), val);
  FSSH1_SendStr(buf, io);
}

/*
** ===================================================================
**     Method      :  FSSH1_SendNum16s (component FSShell)
**
**     Description :
**         Sends a 16bit signed number to the given I/O
**     Parameters  :
**         NAME            - DESCRIPTION
**         val             - number to print
**         io              - I/O callbacks to be used for printing.
**     Returns     : Nothing
** ===================================================================
*/
void FSSH1_SendNum16s(int16_t val, FSSH1_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("-12345")];

  UTIL1_Num16sToStr(buf, sizeof(buf), val);
  FSSH1_SendStr(buf, io);
}

/*
** ===================================================================
**     Method      :  FSSH1_SendNum16u (component FSShell)
**
**     Description :
**         Sends a 16bit unsigned number to the given I/O
**     Parameters  :
**         NAME            - DESCRIPTION
**         val             - number to print
**         io              - I/O callbacks to be used for printing.
**     Returns     : Nothing
** ===================================================================
*/
void FSSH1_SendNum16u(word val, FSSH1_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("12345")];

  UTIL1_Num16uToStr(buf, sizeof(buf), val);
  FSSH1_SendStr(buf, io);
}

/*
** ===================================================================
**     Method      :  FSSH1_SendNum8u (component FSShell)
**
**     Description :
**         Sends an 8bit unsigned number to the given I/O
**     Parameters  :
**         NAME            - DESCRIPTION
**         val             - number to print
**         io              - I/O callbacks to be used for printing.
**     Returns     : Nothing
** ===================================================================
*/
void FSSH1_SendNum8u(byte val, FSSH1_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("123")];

  UTIL1_Num8uToStr(buf, sizeof(buf), val);
  FSSH1_SendStr(buf, io);
}

/*
** ===================================================================
**     Method      :  FSSH1_SendNum8s (component FSShell)
**
**     Description :
**         Sends an 8bit signed number to the given I/O
**     Parameters  :
**         NAME            - DESCRIPTION
**         val             - number to print
**         io              - I/O callbacks to be used for printing.
**     Returns     : Nothing
** ===================================================================
*/
void FSSH1_SendNum8s(signed char val, FSSH1_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("-123")];

  UTIL1_Num8sToStr(buf, sizeof(buf), val);
  FSSH1_SendStr(buf, io);
}

/*
** ===================================================================
**     Method      :  FSSH1_Date (component FSShell)
**
**     Description :
**         Processes the date command
**     Parameters  :
**         NAME            - DESCRIPTION
**       * cmd             - Pointer to command string
**       * io              - Pointer to I/O callbacks
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte FSSH1_Date(const unsigned char *cmd, FSSH1_ConstStdIOType *io)
{
  /* precondition: cmd points to "date" */
  byte day, month;
  word year;
  const unsigned char *p;
  byte res = ERR_OK;

  p = cmd + sizeof("date")-1;
  if (*p==' ') { /* ok, have an argument */
    if (UTIL1_ScanDate(&p, &day, &month, &year) == ERR_OK) { /* ok, format fine */
      if (TmDt1_SetDate(year, month, day) != ERR_OK) {
        FSSH1_SendStr((unsigned char*)"***Failed to set date\r\n", io->stdErr);
        res = ERR_FAILED;
      } else {
      }
    } else {
      FSSH1_SendStr((unsigned char*)"*** error while reading command! ***", io->stdErr);
      FSSH1_SendStr((void *)cmd, io->stdErr);
      FSSH1_SendStr((unsigned char*)"\r\n", io->stdErr);
      res = ERR_FAILED;
    }
  } /* has an argument */
  /* print now current date */
  if (res==ERR_OK) {
    unsigned char buf[sizeof("SW date dd:mm:yyyy\\r\\n")];

    UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"SW date ");
    if (AddSWRTCDate(buf, sizeof(buf))!=ERR_OK) {
      FSSH1_SendStr((unsigned char*)"***Failed to get SW RTC date\r\n", io->stdErr);
      res = ERR_FAILED;
    } else {
      UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
      FSSH1_SendStr(buf, io->stdOut);
    }
  }
  return res;
}

/*
** ===================================================================
**     Method      :  FSSH1_Time (component FSShell)
**
**     Description :
**         Processes the time command
**     Parameters  :
**         NAME            - DESCRIPTION
**       * cmd             - Pointer to command string
**       * io              - Pointer to I/O callbacks
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte FSSH1_Time(const unsigned char *cmd, FSSH1_ConstStdIOType *io)
{
  byte hour, minute, second, hSecond;
  const unsigned char *p;
  byte res = ERR_OK;

  p = cmd + sizeof("time")-1;
  if (*p==' ') { /* has an argument */
    if (UTIL1_ScanTime(&p, &hour, &minute, &second, &hSecond)==ERR_OK) { /* format fine */
      /* set SW RTC time */
      if (TmDt1_SetTime((byte)hour, (byte)minute, (byte)second, hSecond) != ERR_OK) {
        FSSH1_SendStr((unsigned char*)"***Failed to set SW RTC time\r\n", io->stdErr);
        res = ERR_FAILED;
      }
    } else {
      FSSH1_SendStr((unsigned char*)"*** error while reading command: ", io->stdErr);
      FSSH1_SendStr(cmd, io->stdErr);
      FSSH1_SendStr((unsigned char*)"\r\n", io->stdErr);
      res = ERR_FAILED;
    }
  }
  /* print now current time */
  if (res==ERR_OK) {
    unsigned char buf[sizeof("SW time hh:mm:ss.hh\\r\\n")];

    UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)"SW time ");
    if (AddSWRTCTime(buf, sizeof(buf))!=ERR_OK) {
      FSSH1_SendStr((unsigned char*)"***Failed to get SW RTC time\r\n", io->stdErr);
      res = ERR_FAILED;
    } else {
      UTIL1_strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
      FSSH1_SendStr(buf, io->stdOut);
    }
  }
  return res;
}

/*
** ===================================================================
**     Method      :  FSSH1_ShellCmd (component FSShell)
**
**     Description :
**         Parses a shell command. Use 'help' to get a list of
**         supported commands.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * cmd             - Pointer to command string
**       * handled         - Pointer to variable to indicate if
**                           the command has been handled. The caller
**                           passes this variable to the command scanner
**                           to find out if the passed command has been
**                           handled. The variable is initialized by the
**                           caller.
**       * io              - Pointer to I/O callbacks
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte FSSH1_ShellCmd(const unsigned char *cmd, bool *handled, FSSH1_ConstStdIOType *io)
{
  if (UTIL1_strcmp((char*)cmd, FSSH1_CMD_HELP)==0 || UTIL1_strcmp((char*)cmd, "FSSH1 help")==0) {
    FSSH1_SendStr((unsigned char*)FSSH1_DASH_LINE, io->stdOut);
    FSSH1_SendStr((unsigned char*)"\r\n", io->stdOut);
    FSSH1_SendStr((unsigned char*)"Freedom Board Shell", io->stdOut);
    FSSH1_SendStr((unsigned char*)"\r\n", io->stdOut);
    FSSH1_SendStr((unsigned char*)FSSH1_DASH_LINE, io->stdOut);
    FSSH1_SendStr((unsigned char*)"\r\n", io->stdOut);
    FSSH1_SendHelpStr((unsigned char*)"FSSH1", (const unsigned char*)"Group of FSSH1 commands\r\n", io->stdOut);
    FSSH1_SendHelpStr((unsigned char*)"  help|status", (const unsigned char*)"Print help or status information\r\n", io->stdOut);
    FSSH1_SendHelpStr((unsigned char*)"  time [hh:mm:ss[,z]]", (const unsigned char*)"Set the current time. Prints the current time if no argument\r\n", io->stdOut);
    FSSH1_SendHelpStr((unsigned char*)"  date [dd.mm.yyyy]", (const unsigned char*)"Set the current date. Prints the current date if no argument\r\n", io->stdOut);
    *handled = TRUE;
    return ERR_OK;
  } else if ((UTIL1_strcmp((char*)cmd, FSSH1_CMD_STATUS)==0) || (UTIL1_strcmp((char*)cmd, "FSSH1 status")==0)) {
    *handled = TRUE;
    return FSSH1_PrintStatus(io);
  } else if (UTIL1_strncmp((char*)cmd, "date", sizeof("date")-1)==0) {
    *handled = TRUE;
    return FSSH1_Date(cmd, io);
  } else if (UTIL1_strncmp((char*)cmd, "time", sizeof("time")-1)==0) {
    *handled = TRUE;
    return FSSH1_Time(cmd, io);
  }
  return ERR_OK; /* no error */
}

/*
** ===================================================================
**     Method      :  FSSH1_PrintPrompt (component FSShell)
**
**     Description :
**         Prints the prompt to the stdOut channel
**     Parameters  :
**         NAME            - DESCRIPTION
**       * io              - Pointer to IO to be used
**     Returns     : Nothing
** ===================================================================
*/
void FSSH1_PrintPrompt(FSSH1_ConstStdIOType *io)
{
  FSSH1_SendStr((unsigned char*)"CMD> ", io->stdOut);
}

/*
** ===================================================================
**     Method      :  FSSH1_ReadLine (component FSShell)
**
**     Description :
**         Reads a line from stdIn and returns TRUE if we have a line,
**         FALSE otherwise.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * buf             - Pointer to buffer where to read in the
**                           information
**         bufSize         - size of buffer
**       * io              - Pointer to I/O callbacks
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
bool FSSH1_ReadLine(byte *buf, size_t bufSize, FSSH1_ConstStdIOType *io)
{
  byte c;

  if (io->keyPressed()) {
    for(;;) {                          /* while not '\r' or '\n' */
      c = '\0';                        /* initialize character */
      io->stdIn(&c);                   /* read character */
      *buf = (byte)c;                  /* append character to the string */
      if (c=='\0') { /* nothing in rx buffer? */
        break; /* get out of loop */
      }
      buf++;
      bufSize--;
      if ((c=='\r') || (c=='\n')) {
        break;
      }
      if (bufSize <= 1) {              /* buffer full */
        break;
      }
    } /* for */
    *buf = '\0';                       /* zero terminate string */
    return TRUE;
  } else {
    return FALSE;
  }
}

/*
** ===================================================================
**     Method      :  FSSH1_PrintStatus (component FSShell)
**
**     Description :
**         Prints various available system status information
**     Parameters  :
**         NAME            - DESCRIPTION
**       * io              - Pointer to I/O callbacks
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte FSSH1_PrintStatus(FSSH1_ConstStdIOType *io)
{
  byte res = ERR_OK;
  byte buf[16];
#if configUSE_TRACE_FACILITY || configGENERATE_RUN_TIME_STATS /* FreeRTOS trace feature enabled */
#if FRTOS_MEMORY_SCHEME==1 /* this scheme does not allow deallocation of memory */
  static unsigned char *taskListBufferP=NULL; /* allocated only once, never deallocated! */
#else
  unsigned char *taskListBufferP;
#endif
  size_t bufSize;
#endif

  FSSH1_SendStr((unsigned char*)FSSH1_DASH_LINE, io->stdOut);
  FSSH1_SendStr((unsigned char*)"\r\nSYSTEM STATUS\r\n", io->stdOut);
  FSSH1_SendStr((unsigned char*)FSSH1_DASH_LINE, io->stdOut);
  FSSH1_SendStr((unsigned char*)"\r\n", io->stdOut);
#if configUSE_TRACE_FACILITY /* FreeRTOS trace feature enabled */
  FSSH1_SendStr((unsigned char*)"TASK LIST:\r\nName\t\tStatus\tPrio\tStack\tTCB#\r\n", io->stdOut);
  FSSH1_SendStr((unsigned char*)FSSH1_DASH_LINE, io->stdOut);
  /* task list and status */
  bufSize = 40*uxTaskGetNumberOfTasks();  /* about 40 bytes for a task should be enough */
#if FRTOS_MEMORY_SCHEME==1 /* this scheme does not allow deallocation of memory */
  if (taskListBufferP==NULL) { /* only if not allocated yet */
    taskListBufferP = FRTOS1_pvPortMalloc(bufSize); /* about 40 bytes for a task should be enough */
  }
#else
  taskListBufferP = FRTOS1_pvPortMalloc(bufSize); /* about 40 bytes for a task should be enough */
#endif
  if (taskListBufferP != NULL) {
    FRTOS1_vTaskList(taskListBufferP, bufSize);
    FSSH1_SendStr(taskListBufferP, io->stdOut);
#if FRTOS_MEMORY_SCHEME!=1 /* this scheme does not allow deallocation of memory */
    FRTOS1_vPortFree(taskListBufferP);
#endif
  } else {
    FSSH1_SendStr((unsigned char*)"\r\n*** out of heap! ***\r\n", io->stdErr);
  }
#endif
#if configGENERATE_RUN_TIME_STATS
  FSSH1_SendStr((unsigned char*)FSSH1_DASH_LINE, io->stdOut);
  FSSH1_SendStr((unsigned char*)"\r\nRTOS RUN-TIME STATISTICS:\r\nName\tTime (ms)\t%Time\r\n", io->stdOut);
  FSSH1_SendStr((unsigned char*)FSSH1_DASH_LINE, io->stdOut);
  /* task list and status */
  bufSize = 40*uxTaskGetNumberOfTasks();  /* about 40 bytes for a task should be enough */
#if FRTOS_MEMORY_SCHEME==1 /* this scheme does not allow deallocation of memory */
  if (taskListBufferP==NULL) { /* only if not allocated yet */
    taskListBufferP = FRTOS1_pvPortMalloc(bufSize);
  }
#else
  taskListBufferP = FRTOS1_pvPortMalloc(bufSize);
#endif
  if (taskListBufferP != NULL) {
    FRTOS1_vTaskGetRunTimeStats(taskListBufferP, bufSize);
    FSSH1_SendStr(taskListBufferP, io->stdOut);
#if FRTOS_MEMORY_SCHEME!=1 /* this scheme does not allow deallocation of memory */
    FRTOS1_vPortFree(taskListBufferP);
#endif
  }
#endif
  FSSH1_SendStatusStr((unsigned char*)"RTOS ticks", (const unsigned char*)"", io->stdOut);
  UTIL1_Num16sToStr(buf, sizeof(buf), configTICK_RATE_HZ);
  FSSH1_SendStr(buf, io->stdOut);
  FSSH1_SendStr((unsigned char*)" Hz, ", io->stdOut);
  UTIL1_Num16sToStr(buf, sizeof(buf), 1000/configTICK_RATE_HZ);
  FSSH1_SendStr(buf, io->stdOut);
  FSSH1_SendStr((unsigned char*)" ms\r\n", io->stdOut);
  FSSH1_SendStatusStr((unsigned char*)"Free heap", (const unsigned char*)"", io->stdOut);
  UTIL1_Num32uToStr(buf, sizeof(buf), FRTOS1_xPortGetFreeHeapSize());
  FSSH1_SendStr(buf, io->stdOut);
  FSSH1_SendStr((unsigned char*)" bytes\r\n", io->stdOut);
  FSSH1_SendStatusStr((const unsigned char*)"Firmware", (const unsigned char*)__DATE__, io->stdOut);
  FSSH1_SendStr((unsigned char*)" ", io->stdOut);
  FSSH1_SendStr((unsigned char*)__TIME__, io->stdOut);
  FSSH1_SendStr((unsigned char*)"\r\n", io->stdOut);
  FSSH1_SendStatusStr((unsigned char*)"SW RTC", (const unsigned char*)"", io->stdOut);
  buf[0] = '\0';
  if (AddSWRTCDate(buf, sizeof(buf))!=ERR_OK) {
    FSSH1_SendStr((unsigned char*)"***Failed to get SW RTC date! ", io->stdErr);
    res = ERR_FAILED;
  } else {
    FSSH1_SendStr(buf, io->stdOut);
  }
  UTIL1_strcpy(buf, sizeof(buf), (unsigned char*)" ");
  if (AddSWRTCTime(buf, sizeof(buf))!=ERR_OK) {
    FSSH1_SendStr((unsigned char*)"***Failed to get SW RTC time! ", io->stdErr);
  } else {
    FSSH1_SendStr(buf, io->stdOut);
  }
  FSSH1_SendStr((unsigned char*)"\r\n", io->stdOut);
  return res;
}

/*
** ===================================================================
**     Method      :  FSSH1_PrintCommandFailed (component FSShell)
**
**     Description :
**         Prints a standard message for failed or unknown commands
**     Parameters  :
**         NAME            - DESCRIPTION
**       * cmd             - Pointer to command which was failing
**       * io              - Pointer to I/O callbacks
**     Returns     : Nothing
** ===================================================================
*/
void FSSH1_PrintCommandFailed(const unsigned char *cmd, FSSH1_ConstStdIOType *io)
{
  FSSH1_SendStr((unsigned char*)"*** Failed or unknown command: ", io->stdErr);
  FSSH1_SendStr(cmd, io->stdErr);
  FSSH1_SendStr((unsigned char*)"\r\n", io->stdErr);
  FSSH1_SendStr((unsigned char*)"*** Type ", io->stdErr);
  FSSH1_SendStr((unsigned char*)FSSH1_CMD_HELP, io->stdErr);
  FSSH1_SendStr((unsigned char*)" to get a list of available commands\r\n", io->stdErr);
}

/*
** ===================================================================
**     Method      :  FSSH1_ParseCommand (component FSShell)
**
**     Description :
**         Parses a shell command. It handles first the internal
**         commands and will call the provided callback.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * cmd             - Pointer to command string
**       * io              - Pointer to I/O callbacks
**         parseCallback   - callback which will be
**                           called to parse commands in the user
**                           application, or NULL if not used.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte FSSH1_ParseCommand(const unsigned char *cmd, FSSH1_ConstStdIOType *io, FSSH1_ParseCommandCallback parseCallback)
{
  byte res = ERR_OK;
  bool handled;
  bool silent;

  if (*cmd=='\0') { /* empty command */
    return ERR_OK;
  }
  /* parse first shell commands */
  handled = FALSE;
  silent = (bool)(*cmd=='#');
  if (silent) {
    cmd++; /* skip '#' */
  }
  if (FSSH1_ShellCmd(cmd, &handled, io)!=ERR_OK) {
    return ERR_FAILED;
  }
  /* parse application commands */
  if ((parseCallback!=NULL && parseCallback(cmd, &handled, io)!=ERR_OK) || !handled) { /* call other handlers */
    FSSH1_PrintCommandFailed(cmd, io);
    res = ERR_FAILED;
  }
  if (!silent) {
    FSSH1_PrintPrompt(io);
  }
  return res;
}

/*
** ===================================================================
**     Method      :  FSSH1_GetStdio (component FSShell)
**
**     Description :
**         Returns the default stdio channel. This method is only
**         available if a shell is enabled in the component properties.
**     Parameters  : None
**     Returns     :
**         ---             - Pointer to the stdio descriptor
** ===================================================================
*/
FSSH1_ConstStdIOTypePtr FSSH1_GetStdio(void)
{
  static FSSH1_ConstStdIOType FSSH1_stdio =
  {
    (FSSH1_StdIO_In_FctType)FSSH1_ReadChar, /* stdin */
    (FSSH1_StdIO_OutErr_FctType)FSSH1_SendChar, /* stdout */
    (FSSH1_StdIO_OutErr_FctType)FSSH1_SendChar, /* stderr */
    FSSH1_KeyPressed /* if input is not empty */
  };

  return &FSSH1_stdio;
}

/*
** ===================================================================
**     Method      :  FSSH1_ReadAndParseLine (component FSShell)
**
**     Description :
**         Reads characters from the default input channel and appends
**         it to the buffer. Once a new line has been detected, the
**         line will be parsed.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * cmdBuf          - Pointer to buffer provided by the
**                           caller where to store the command to read
**                           in. Characters will be appended, so make
**                           sure string buffer is initialized with a
**                           zero byte at the beginning.
**         cmdBufSize      - Size of buffer
**       * io              - Pointer to I/O channels to be used
**         parseCallback   - callback provided by
**                           the user application to parse user commands.
**                           If not used, NULL can be passed.
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte FSSH1_ReadAndParseLine(byte *cmdBuf, size_t cmdBufSize, FSSH1_ConstStdIOType *io, FSSH1_ParseCommandCallback parseCallback)
{
  byte res = ERR_OK;
  size_t len;

  /* IMPORTANT NOTE: this function *appends* to the buffer, so the buffer needs to be initialized first! */
  len = UTIL1_strlen((const char*)cmdBuf);
  if (FSSH1_ReadLine(cmdBuf+len, cmdBufSize-len, io)) {
    len = UTIL1_strlen((const char*)cmdBuf); /* length of buffer string */
    if (len==0) { /* error case */
      return ERR_FAILED;
    } else if (len==1 && (cmdBuf[0]=='\n' || cmdBuf[0]=='\r')) { /* eat preceding newline characters */
      cmdBuf[0] = '\0';
    }
    if (len>=cmdBufSize-1) {           /* buffer overflow? Parse what we have, will be likely return an error */
      res = FSSH1_ParseCommand(cmdBuf, io, parseCallback);
      cmdBuf[0] = '\0'; /* start again */
      res = ERR_OVERFLOW;
    } else if (cmdBuf[len-1]=='\n' || cmdBuf[len-1]=='\r') { /* line end: parse command */
      cmdBuf[len-1] = '\0';            /* remove line end character for parser */
      res = FSSH1_ParseCommand(cmdBuf, io, parseCallback);
      cmdBuf[0] = '\0';                /* start again */
    } else {
      /* continue to append to buffer */
    }
  }
  return res;
}

/*
** ===================================================================
**     Method      :  FSSH1_RequestSerial (component FSShell)
**
**     Description :
**         Used to get mutual access to the shell console. Only has an
**         effect if using an RTOS with semaphore for the console
**         access.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void FSSH1_RequestSerial(void)
{
}

/*
** ===================================================================
**     Method      :  FSSH1_ReleaseSerial (component FSShell)
**
**     Description :
**         Used to release mutual access to the shell console. Only has
**         an effect if using an RTOS with semaphore for the console
**         access.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void FSSH1_ReleaseSerial(void)
{
}

/*
** ===================================================================
**     Method      :  FSSH1_GetSemaphore (component FSShell)
**
**     Description :
**         Return the semaphore of the shell.
**     Parameters  : None
**     Returns     :
**         ---             - semaphore, or NULL if not used or not
**                           allocated.
** ===================================================================
*/
void* FSSH1_GetSemaphore(void)
{
  return NULL;
}

/*
** ===================================================================
**     Method      :  SendSeparatedStrings (component FSShell)
**
**     Description :
**         Prints a string using an I/O function, formated for the 'help' 
**         command
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void SendSeparatedStrings(const byte *strA, const byte *strB, byte tabChar, byte tabPos, FSSH1_StdIO_OutErr_FctType io)
{
  /* write command part */
  while(*strA!='\0' && tabPos>0) {
    io(*strA++);
    tabPos--;
  }
  /* fill up until ';' */
  while(tabPos>0) {
    io(' ');
    tabPos--;
  }
  /* write separator */
  io(tabChar);
  io(' ');
  /* write help text */
  FSSH1_SendStr(strB, io);
}

/*
** ===================================================================
**     Method      :  FSSH1_SendHelpStr (component FSShell)
**
**     Description :
**         Prints a string using an I/O function, formated for the
**         'help' command
**     Parameters  :
**         NAME            - DESCRIPTION
**       * strCmd          - Pointer to string of the command
**       * strHelp         - Pointer to help text string
**         io              - I/O callbacks to be used for printing.
**     Returns     : Nothing
** ===================================================================
*/
void FSSH1_SendHelpStr(const byte *strCmd, const byte *strHelp, FSSH1_StdIO_OutErr_FctType io)
{
  #define HELP_SEMICOLON_POS  26 /* position of the ';' after the command string */
  SendSeparatedStrings(strCmd, strHelp, ';', HELP_SEMICOLON_POS, io);
}

/*
** ===================================================================
**     Method      :  FSSH1_SendStatusStr (component FSShell)
**
**     Description :
**         Prints a status string using an I/O function, formated for
**         the 'status' command
**     Parameters  :
**         NAME            - DESCRIPTION
**       * strItem         - Pointer to string of the command
**       * strStatus       - Pointer to help text string
**         io              - I/O callbacks to be used for printing.
**     Returns     : Nothing
** ===================================================================
*/
void FSSH1_SendStatusStr(const byte *strItem, const byte *strStatus, FSSH1_StdIO_OutErr_FctType io)
{
  #define STATUS_COLON_POS  13 /* position of the ':' after the item string */
  SendSeparatedStrings(strItem, strStatus, ':', STATUS_COLON_POS, io);
}

/*
** ===================================================================
**     Method      :  FSSH1_ReadChar (component FSShell)
**
**     Description :
**         Reads a character (blocking)
**     Parameters  :
**         NAME            - DESCRIPTION
**       * c               - Pointer to character to be used to store the
**                           result
**     Returns     : Nothing
** ===================================================================
*/
void FSSH1_ReadChar(byte *c)
{
  if (RxBuf3_Get(c)!=ERR_OK) {
    /* failed to receive character: return a zero character */
    *c = '\0';
  }
}

/*
** ===================================================================
**     Method      :  FSSH1_SendChar (component FSShell)
**
**     Description :
**         Sends a character (blocking)
**     Parameters  :
**         NAME            - DESCRIPTION
**         ch              - character to be sent
**     Returns     : Nothing
** ===================================================================
*/
void FSSH1_SendChar(byte ch)
{
  FSSH1_SentFlag = 0;                  /* this will be set to 1 once the block has been sent */
  while(AS1_SendBlock(serialHandle, (LDD_TData*)&ch, 1)!=ERR_OK) {} /* Send char */
  while(FSSH1_SentFlag==0) {}          /* wait until we get the green flag from the TX interrupt */
}

/*
** ===================================================================
**     Method      :  FSSH1_KeyPressed (component FSShell)
**
**     Description :
**         Checks if a key has been pressed (a character is present in
**         the input buffer)
**     Parameters  : None
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
bool FSSH1_KeyPressed(void)
{
  bool res;

  res = RxBuf3_NofElements()!=0;
  return res;
}

/*
** ===================================================================
**     Method      :  FSSH1_Init (component FSShell)
**
**     Description :
**         Initializes the module, especially creates the mutex
**         semaphore if an RTOS is used.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void FSSH1_Init(void)
{
  /* initialize logical device driver */
  serialHandle = AS1_Init(NULL);
  /* set up to receive RX into input buffer */
  RxBuf3_Init(); /* initialize RX buffer */
  /* Set up ReceiveBlock() with a single byte buffer. We will be called in OnBlockReceived() event. */
  charBuf = '\0'; /* initialize buffer character */
  while(AS1_ReceiveBlock(serialHandle, (LDD_TData *)&charBuf, sizeof(charBuf))!=ERR_OK) {}
}

/*
** ===================================================================
**     Method      :  FSSH1_Deinit (component FSShell)
**
**     Description :
**         De-Initializes the module, especially frees the mutex
**         semaphore if an RTOS is used.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void FSSH1_Deinit(void)
{
  /* de-initialize logical device driver */
  AS1_Deinit(serialHandle);
}

/*
** ===================================================================
**     Method      :  FSSH1_OnBlockReceived (component FSShell)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void AS1_OnBlockReceived(LDD_TUserData *UserDataPtr)
{
  (void)UserDataPtr; /* argument not used */
  (void)RxBuf3_Put(charBuf); /* but received character into buffer */
  (void)AS1_ReceiveBlock(serialHandle, (LDD_TData *)&charBuf, sizeof(charBuf));
}

/*
** ===================================================================
**     Method      :  FSSH1_OnBlockSent (component FSShell)
**
**     Description :
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void AS1_OnBlockSent(LDD_TUserData *UserDataPtr)
{
  (void)UserDataPtr; /* unused argument */
  FSSH1_SentFlag = 1; /* set flag so sender knows we have finished */
}

/* END FSSH1. */

/*
** ###################################################################
**
**     This file was created by Processor Expert 10.0 [05.03]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
