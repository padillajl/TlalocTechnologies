=============================================================================
List of generated methods in project: ProcessorExpert

THIS TEXT DESCRIPTION IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
=============================================================================

Module "LEDR"      (component LED)
   - LEDR_On -This turns the LED on.
   - LEDR_Off -This turns the LED off.
   - LEDR_Neg -This negates/toggles the LED
   - LEDR_Get -This returns logical 1 in case the LED is on, 0 otherwise.
   - LEDR_Put -Turns the LED on or off.
   - LEDR_Init -Performs the LED driver initialization.
   - LEDR_Deinit -Deinitializes the driver
   - LEDR_ParseCommand -Shell Command Line parser
   - LEDR_SetRatio16 -Method to specify the duty cylce. If using a PWM pin, this means the duty cycle is set. For On/off pins, 
                values smaller 0x7FFF means off, while values greater means on.

Module "LEDG"      (component LED)
   - LEDG_On -This turns the LED on.
   - LEDG_Off -This turns the LED off.
   - LEDG_Neg -This negates/toggles the LED
   - LEDG_Get -This returns logical 1 in case the LED is on, 0 otherwise.
   - LEDG_Put -Turns the LED on or off.
   - LEDG_Init -Performs the LED driver initialization.
   - LEDG_Deinit -Deinitializes the driver
   - LEDG_ParseCommand -Shell Command Line parser
   - LEDG_SetRatio16 -Method to specify the duty cylce. If using a PWM pin, this means the duty cycle is set. For On/off pins, 
                values smaller 0x7FFF means off, while values greater means on.

Module "LEDB"      (component LED)
   - LEDB_On -This turns the LED on.
   - LEDB_Off -This turns the LED off.
   - LEDB_Neg -This negates/toggles the LED
   - LEDB_Get -This returns logical 1 in case the LED is on, 0 otherwise.
   - LEDB_Put -Turns the LED on or off.
   - LEDB_Init -Performs the LED driver initialization.
   - LEDB_Deinit -Deinitializes the driver
   - LEDB_ParseCommand -Shell Command Line parser
   - LEDB_SetRatio16 -Method to specify the duty cylce. If using a PWM pin, this means the duty cycle is set. For On/off pins, 
                values smaller 0x7FFF means off, while values greater means on.

Module "FRTOS1"    (component FreeRTOS)
   - FRTOS1_xTaskCreate -Create a new task and add it to the list of tasks that are ready to run.
   - FRTOS1_vTaskStartScheduler -Starts the real time kernel tick processing. After calling the kernel has control over which 
                tasks are executed and when.   The idle task is created automatically when vTaskStartScheduler() is called.   
                If vTaskStartScheduler() is successful the function will not return until an executing task calls 
                vTaskEndScheduler(). The function might fail and return immediately if there is insufficient RAM available for 
                the idle task to be created.
   - FRTOS1_vTaskSuspend -Suspend any task. When suspended a task will never get any microcontroller processing time, no matter 
                what its priority. Calls to vTaskSuspend are not accumulative - i.e. calling vTaskSuspend() twice on the same 
                task still only requires one call to vTaskResume() to ready the suspended task.
   - FRTOS1_vTaskSuspendAll -Suspends all real time kernel activity while keeping interrupts (including the kernel tick) 
                enabled.   After calling vTaskSuspendAll () the calling task will continue to execute without risk of being 
                swapped out until a call to xTaskResumeAll () has been made.   API functions that have the potential to cause a 
                context switch (for example, vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler is 
                suspended.
   - FRTOS1_vTaskResume -Resumes a suspended task. A task that has been suspended by one of more calls to vTaskSuspend() will 
                be made available for running again by a single call to vTaskResume().
   - FRTOS1_xTaskResumeAll -Resumes real time kernel activity following a call to vTaskSuspendAll (). After a call to 
                xTaskSuspendAll () the kernel will take control of which task is executing at any time.
   - FRTOS1_xTaskResumeFromISR -An implementation of vTaskResume() that can be called from within an ISR. A task that has been 
                suspended by one of more calls to vTaskSuspend() will be made available for running again by a single call to 
                xTaskResumeFromISR().
   - FRTOS1_taskYIELD -Macro for forcing a context switch.
   - FRTOS1_taskENTER_CRITICAL -Macro to mark the start of a critical code region. Preemptive context switches cannot occur 
                when in a critical region.      NOTE: This may alter the stack (depending on the portable implementation) so 
                must be used with care!
   - FRTOS1_taskEXIT_CRITICAL -Macro to mark the end of a critical code region. Preemptive context switches cannot occur when 
                in a critical region.      NOTE: This may alter the stack (depending on the portable implementation) so must be 
                used with care!
   - FRTOS1_taskDISABLE_INTERRUPTS -Macro to disable all maskable interrupts.
   - FRTOS1_taskENABLE_INTERRUPTS -Macro to enable microcontroller interrupts.
   - FRTOS1_vTaskDelay -Delay a task for a given number of ticks. The actual time that the task remains blocked depends on the 
                tick rate. The constant portTICK_RATE_MS can be used to calculate real time from the tick rate - with the 
                resolution of one tick period.      vTaskDelay() specifies a time at which the task wishes to unblock relative 
                to the time at which vTaskDelay() is called. For example, specifying a block period of 100 ticks will cause the 
                task to unblock 100 ticks after vTaskDelay() is called. vTaskDelay() does not therefore provide a good method 
                of controlling the frequency of a cyclical task as the path taken through the code, as well as other task and 
                interrupt activity, will effect the frequency at which vTaskDelay() gets called and therefore the time at which 
                the task next executes. See vTaskDelayUntil() for an alternative API function designed to facilitate fixed 
                frequency execution. It does this by specifying an absolute time (rather than a relative time) at which the 
                calling task should unblock.
   - FRTOS1_vTaskDelayUntil -Delay a task until a specified time. This function can be used by cyclical tasks to ensure a 
                constant execution frequency.      This function differs from vTaskDelay() in one important aspect: 
                vTaskDelay() specifies a time at which the task wishes to unblock relative to the time at which vTaskDelay() is 
                called, whereas vTaskDelayUntil() specifies an absolute time at which the task wishes to unblock.      
                vTaskDelay() will cause a task to block for the specified number of ticks from the time vTaskDelay() is called. 
                It is therefore difficult to use vTaskDelay() by itself to generate a fixed execution frequency as the time 
                between a task unblocking following a call to vTaskDelay() and that task next calling vTaskDelay() may not be 
                fixed [the task may take a different path though the code between calls, or may get interrupted or preempted a 
                different number of times each time it executes].      Whereas vTaskDelay() specifies a wake time relative to 
                the time at which the function is called, vTaskDelayUntil() specifies the absolute (exact) time at which it 
                wishes to unblock.      It should be noted that vTaskDelayUntil() will return immediately (without blocking) if 
                it is used to specify a wake time that is already in the past. Therefore a task using vTaskDelayUntil() to 
                execute periodically will have to re-calculate its required wake time if the periodic execution is halted for 
                any reason (for example, the task is temporarily placed into the Suspended state) causing the task to miss one 
                or more periodic executions. This can be detected by checking the variable passed by reference as the 
                pxPreviousWakeTime parameter against the current tick count. This is however not necessary under most usage 
                scenarios.      The constant portTICK_RATE_MS can be used to calculate real time from the tick rate - with the 
                resolution of one tick period.      This function must not be called while the scheduler has been suspended by 
                a call to vTaskSuspendAll().
   - FRTOS1_uxTaskPriorityGet -Obtain the priority of any task.
   - FRTOS1_vTaskPrioritySet -Set the priority of any task.
   - FRTOS1_xTaskGetTickCount -Return the count of ticks since vTaskStartScheduler was called.
   - FRTOS1_xSemaphoreCreateRecursiveMutex -Macro that implements a recursive mutex by using the existing queue mechanism.   
                Mutexes created using this macro can be accessed using the xSemaphoreTakeRecursive() and 
                xSemaphoreGiveRecursive() macros.  The  xSemaphoreTake() and xSemaphoreGive() macros should not be used.   A 
                mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until 
                the owner has called xSemaphoreGiveRecursive() for each successful 'take' request.  For example, if a task 
                successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has 
                also  'given' the mutex back exactly five times.   This type of semaphore uses a priority inheritance mechanism 
                so a task 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the semaphore it is no longer 
                required. Mutex type semaphores cannot be used from within interrupt service routines.   See 
                vSemaphoreCreateBinary() for an alternative implementation that can be used for pure synchronisation (where one 
                task or interrupt always 'gives' the semaphore and another always 'takes' the semaphore) and from within 
                interrupt service routines.
   - FRTOS1_xSemaphoreTakeRecursive -Macro to recursively obtain, or 'take', a mutex type semaphore. The mutex must have 
                previously been created using a call to xSemaphoreCreateRecursiveMutex();   This macro must not be used on 
                mutexes created using xSemaphoreCreateMutex(). A mutex used recursively can be 'taken' repeatedly by the owner. 
                The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each 
                successful 'take' request.  For example, if a task successfully 'takes' the same mutex 5 times then the mutex 
                will not be available to any other task until it has also  'given' the mutex back exactly five times.
   - FRTOS1_xSemaphoreGiveRecursive -Macro to recursively release, or 'give', a mutex type semaphore. The mutex must have 
                previously been created using a call to xSemaphoreCreateRecursiveMutex();   This macro must not be used on 
                mutexes created using xSemaphoreCreateMutex(). A mutex used recursively can be 'taken' repeatedly by the owner. 
                The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each 
                successful 'take' request.  For example, if a task successfully 'takes' the same mutex 5 times then the mutex 
                will not be available to any other task until it has also  'given' the mutex back exactly five times.
   - FRTOS1_xSemaphoreCreateMutex -Macro that creates a mutex semaphore by using the existing queue mechanism.      Mutexes 
                created using this macro can be accessed using the xSemaphoreTake() and xSemaphoreGive() macros. The 
                xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros should not be used.      Mutexes and binary 
                semaphores are very similar but have some subtle differences: Mutexes include a priority inheritance mechanism, 
                binary semaphores do not. This makes binary semaphores the better choice for implementing synchronisation 
                (between tasks or between tasks and an interrupt), and mutexes the better choice for implementing simple mutual 
                exclusion.      The priority of a task that 'takes' a mutex can potentially be raised if another task of higher 
                priority attempts to obtain the same mutex. The task that owns the mutex 'inherits' the priority of the task 
                attempting to 'take' the same mutex. This means the mutex must always be 'given' back - otherwise the higher 
                priority task will never be able to obtain the mutex, and the lower priority task will never 'disinherit' the 
                priority. An example of a mutex being used to implement mutual exclusion is provided on the xSemaphoreTake() 
                documentation page.      A binary semaphore need not be given back once obtained, so task synchronisation can 
                be implemented by one task/interrupt continuously 'giving' the semaphore while another continuously 'takes' the 
                semaphore. This is demonstrated by the sample code on the xSemaphoreGiveFromISR() documentation page.      Both 
                mutex and binary semaphores are assigned to variables of type xSemaphoreHandle and can be used in any API 
                function that takes a parameter of this type.
   - FRTOS1_xSemaphoreTake -Macro to obtain a semaphore. The semaphore must have previously been created with a call to 
                vSemaphoreCreateBinary(), xSemaphoreCreateMutex() or xSemaphoreCreateCounting().      This macro must not be 
                called from an ISR. xQueueReceiveFromISR() can be used to take a semaphore from within an interrupt if required,
                although this would not be a normal operation. Semaphores use queues as their underlying mechanism, so 
                functions are to some extent interoperable.      xSemaphoreTake() is part of the fully featured intertask 
                communications API. xSemaphoreAltTake() is the alternative API equivalent. Both versions require the same 
                parameters and return the same values.
   - FRTOS1_xSemaphoreGive -Macro to release a semaphore. The semaphore must have previously been created with a call to 
                vSemaphoreCreateBinary(), xSemaphoreCreateMutex() or xSemaphoreCreateCounting(), and obtained using 
                sSemaphoreTake().      This must not be used from an ISR. See xSemaphoreGiveFromISR() for an alternative which 
                can be used from an ISR.      This macro must also not be used on semaphores created using 
                xSemaphoreCreateRecursiveMutex().      xSemaphoreGive() is part of the fully featured intertask communications 
                API. xSemaphoreAltGive() is the alternative API equivalent. Both versions require the same parameters and 
                return the same values.
   - FRTOS1_vSemaphoreCreateBinary -Macro that creates a semaphore by using the existing queue mechanism. The queue length is 1 
                as this is a binary semaphore. The data size is 0 as we don't want to actually store any data - we just want to 
                know if the queue is empty or full.      Binary semaphores and mutexes are very similar but have some subtle 
                differences: Mutexes include a priority inheritance mechanism, binary semaphores do not. This makes binary 
                semaphores the better choice for implementing synchronisation (between tasks or between tasks and an interrupt),
                and mutexes the better choice for implementing simple mutual exclusion.      A binary semaphore need not be 
                given back once obtained, so task synchronisation can be implemented by one task/interrupt continuously 
                'giving' the semaphore while another continuously 'takes' the semaphore. This is demonstrated by the sample 
                code on the xSemaphoreGiveFromISR() documentation page.      The priority of a task that 'takes' a mutex can 
                potentially be raised if another task of higher priority attempts to obtain the same mutex. The task that owns 
                the mutex 'inherits' the priority of the task attempting to 'take' the same mutex. This means the mutex must 
                always be 'given' back - otherwise the higher priority task will never be able to obtain the mutex, and the 
                lower priority task will never 'disinherit' the priority. An example of a mutex being used to implement mutual 
                exclusion is provided on the xSemaphoreTake() documentation page.      Both mutex and binary semaphores are 
                assigned to variables of type xSemaphoreHandle and can be used in any API function that takes a parameter of 
                this type.
   - FRTOS1_xSemaphoreCreateCounting -Macro that creates a counting semaphore by using the existing queue mechanism.      
                Counting semaphores are typically used for two things:      1. Counting events.   In this usage scenario an 
                event handler will 'give' a semaphore each time an event occurs (incrementing the semaphore count value), and a 
                handler task will 'take' a semaphore each time it processes an event (decrementing the semaphore count value). 
                The count value is therefore the difference between the number of events that have occurred and the number that 
                have been processed. In this case it is desirable for the initial count value to be zero.      2. Resource 
                management.   In this usage scenario the count value indicates the number of resources available. To obtain 
                control of a resource a task must first obtain a semaphore - decrementing the semaphore count value. When the 
                count value reaches zero there are no free resources. When a task finishes with the resource it 'gives' the 
                semaphore back - incrementing the semaphore count value. In this case it is desirable for the initial count 
                value to be equal to the maximum count value, indicating that all resources are free.
   - FRTOS1_xSemaphoreGiveFromISR -Macro to release a semaphore. The semaphore must have previously been created with a call to 
                vSemaphoreCreateBinary() or xSemaphoreCreateCounting().      Mutex type semaphores (those created using a call 
                to xSemaphoreCreateMutex()) must not be used with this macro.      This macro can be used from an ISR.
   - FRTOS1_xSemaphoreTakeFromISR -Macro to take a semaphore from an ISR. The semaphore must have previously been created with 
                a call to vSemaphoreCreateBinary() or xSemaphoreCreateCounting().      Mutex type semaphores (those created 
                using a call to xSemaphoreCreateMutex()) must not be used with this macro.      This macro can be used from an 
                ISR, however taking a semaphore from an ISR is not a common operation.  It is likely to only be useful when 
                taking a counting semaphore when an interrupt is obtaining an object from a resource pool (when the semaphore 
                count indicates the number of resources available).
   - FRTOS1_vSemaphoreDelete -Delete a semaphore.  This function must be used with care.  For example, do not delete a mutex 
                type semaphore if the mutex is held by a task.
   - FRTOS1_xSemaphoreGetMutexHolder -Returns the holder of a mutex or semaphore. If xMutex is indeed a mutex type semaphore, 
                return the current mutex holder. If xMutex is not a mutex type semaphore, or the mutex is available (not held 
                by a task), return NULL. Note: This Is is a good way of determining if the calling task is the mutex holder, 
                but not a good way of determining the identity of the mutex holder as the holder may change between the 
                function exiting and the returned value being tested.
   - FRTOS1_vTaskList -configUSE_TRACE_FACILITY, INCLUDE_vTaskDelete and INCLUDE_vTaskSuspend must all be defined as 1 for this 
                function to be available. See the configuration section for more information.   NOTE: This function will 
                disable interrupts for its duration.  It is not intended for normal application runtime use but as a debug aid. 
                Lists all the current tasks, along with their current state and stack usage high water mark.   Tasks are 
                reported as blocked ('B'), ready ('R'), deleted ('D') or suspended ('S').
   - FRTOS1_pvPortMalloc -Allocates a memory block using the port pvPortMalloc() function
   - FRTOS1_vPortFree -Frees a memory block previously allocated with pvPortMalloc()
   - FRTOS1_xTaskGetSchedulerState -Returns the state of the scheduler
   - FRTOS1_uxTaskGetStackHighWaterMark -The stack used by a task will grow and shrink as the task executes and interrupts are 
                processed. uxTaskGetStackHighWaterMark() returns the minimum amount of remaining stack space that was available 
                to the task since the task started executing - that is the amount of stack that remained unused when the task 
                stack was at its greatest (deepest) value. This is what is referred to as the stack 'high water mark'.
   - FRTOS1_uxTaskGetNumberOfTasks -Returns the number of tasks
   - FRTOS1_xPortGetFreeHeapSize -Returns the actual free size of the heap
   - FRTOS1_xQueueCreate -Creates a queue.
   - FRTOS1_vQueueDelete -Deletes a queue that was previously created using a call to xQueueCreate(). vQueueDelete() can also 
                be used to delete a semaphore.
   - FRTOS1_xQueueSendToFront -Sends an item to the front of a queue.
   - FRTOS1_xQueueSendToFrontFromISR -Versions of xQueueSendToFront() API functions that can be called from an ISR. Unlike 
                xQueueSendToFront() these functions do not permit a block time to be specified.
   - FRTOS1_xQueueSendToBack -Sends an item to the back of a queue.
   - FRTOS1_xQueueSendToBackFromISR -Versions of xQueueSendToBack() API functions that can be called from an ISR. Unlike 
                xQueueSendToBack() these functions do not permit a block time to be specified.
   - FRTOS1_xQueueReceive -Receives an item from a queue.
   - FRTOS1_xQueueReceivefromISR -A version of xQueueReceive() that can be called from an ISR. Unlike xQueueReceive(), 
                xQueueReceiveFromISR() does not permit a block time to be specified.
   - FRTOS1_xQueuePeek -Reads an item from a queue, but does not remove the item from the queue. Therefore the same item would 
                be returned the next time xQueueReceive() or xQueuePeek() was called on the same queue.
   - FRTOS1_uxQueueMessagesWaiting -Queries the number of items that are currently held within a queue.
   - FRTOS1_uxQueueMessagesWaitingfromISR -A version of uxQueueMessagesWaiting() that can be used from inside an interrupt 
                service routine.
   - FRTOS1_xQueueReset -Reset a queue back to its original empty state.  pdPASS is returned if the queue is successfully reset.
                pdFAIL is returned if the queue could not be reset because there are tasks blocked on the queue waiting to 
                either receive from the queue or send to the queue.

Module "UTIL1"     (component Utility)
   - UTIL1_strcpy -Same as normal strcpy, but safe as it does not write beyond the buffer.
   - UTIL1_strcat -Same as normal strcat, but safe as it does not write beyond the buffer.
   - UTIL1_chcat -Adds a single character to a zero byte terminated buffer. It cares about buffer overflow.
   - UTIL1_Num8sToStr -Converts a signed 8bit value into a string.
   - UTIL1_Num8uToStr -Converts an unsigned 8bit value into a string.
   - UTIL1_Num16sToStr -Converts a signed 16bit value into a string.
   - UTIL1_Num16uToStr -Converts a signed 16bit value into a string.
   - UTIL1_Num32uToStr -Converts an unsigned 32bit value into a string.
   - UTIL1_Num32sToStr -Converts a signed 32bit value into a string.
   - UTIL1_Num16sToStrFormatted -Converts a 16bit signed value to string.
   - UTIL1_Num16uToStrFormatted -Converts a 16bit unsigned value to string.
   - UTIL1_Num32uToStrFormatted -Converts a 32bit unsigned value to string.
   - UTIL1_Num32sToStrFormatted -Converts a 32bit signed value to string.
   - UTIL1_strcatNum8u -Appends a 8bit unsigned value to a string buffer.
   - UTIL1_strcatNum8s -Appends a 8bit signed value to a string buffer.
   - UTIL1_strcatNum16u -Appends a 16bit unsigned value to a string buffer.
   - UTIL1_strcatNum16s -Appends a 16bit signed value to a string buffer.
   - UTIL1_strcatNum32u -Appends a 32bit signed value to a string buffer.
   - UTIL1_strcatNum32s -Appends a 32bit signed value to a string buffer.
   - UTIL1_strcatNum16uFormatted -Appends a 16bit unsigned value to a string buffer in a formatted way.
   - UTIL1_strcatNum16sFormatted -Appends a 16bit signed value to a string buffer in a formatted way.
   - UTIL1_strcatNum32uFormatted -Appends a 32bit unsigned value to a string buffer in a formatted way.
   - UTIL1_strcatNum32sFormatted -Appends a 32bit signed value to a string buffer in a formatted way.
   - UTIL1_strcatNum8Hex -Appends a 8bit unsigned value to a buffer as hex number (without a 0x prefix).
   - UTIL1_strcatNum16Hex -Appends a 16bit unsigned value to a buffer as hex number (without a 0x prefix).
   - UTIL1_strcatNum24Hex -Appends a 32bit unsigned value to a buffer as hex number (without a 0x prefix). Only 24bits are used.
   - UTIL1_strcatNum32Hex -Appends a 16bit unsigned value to a buffer as hex number (without a 0x prefix).
   - UTIL1_IsLeapYear -Returns true if a given year is a leap year
   - UTIL1_WeekDay -Returns the weekday for a given date >= 1.Jan.1900
   - UTIL1_ReadEscapedName -Scans an escaped name from a string. This is useful e.g. for double quoted file names.
   - UTIL1_xatoi -Custom atoi() (ascii to int) implementation by Elm Chan
   - UTIL1_ScanDate -Scans a date in the format "dd.mm.yyyy" or "dd-mm-yyyy". For yy it will expand it to 20yy.
   - UTIL1_ScanTime -Scans a time string in the format "hh:mm:ss,hh" with the part for the ",hh" is optional.
   - UTIL1_ScanDecimal8uNumber -Scans a decimal 16bit unsigned number
   - UTIL1_ScanDecimal16uNumber -Scans a decimal 16bit unsigned number
   - UTIL1_ScanDecimal32uNumber -Scans a decimal 32bit unsigned number
   - UTIL1_ScanHex8uNumber -Scans a hexadecimal 8bit number, starting with 0x
   - UTIL1_ScanHex16uNumber -Scans a hexadecimal 16bit number, starting with 0x
   - UTIL1_ScanHex32uNumber -Scans a hexadecimal 32bit number, starting with 0x
   - UTIL1_strcmp -Wrapper to the standard strcmp() routine
   - UTIL1_strncmp -Wrapper to the standard strncmp() routine
   - UTIL1_strlen -Wrapper to the standard strlen() function.

Module "WAIT1"     (component Wait)
   - WAIT1_Wait10Cycles -Wait for approximately 10 CPU cycles.
   - WAIT1_Wait100Cycles -Wait for 100 CPU cycles.
   - WAIT1_WaitCycles -Wait for 100 CPU cycles.
   - WAIT1_Waitms -Wait for a specified time in milliseconds.
   - WAIT1_Waitus -Wait for a specified time in microseconds.
   - WAIT1_Waitns -Wait for a specified time in nano seconds.
   - WAIT1_WaitOSms -If an RTOS is enabled, this routine will use a non-blocking wait method. Otherwise it will do a 
                busy/blocking wait.

Module "TmDt1"     (component GenericTimeDate)
   - TmDt1_AddTick -Needs to be called periodically by the application to increase the time tick count.
   - TmDt1_SetTime -This method sets a new actual time.
   - TmDt1_GetTime -This method returns current time.
   - TmDt1_SetDate -This method sets a new actual date.
   - TmDt1_GetDate -This method returns current date.
   - TmDt1_Init -Initialization method

Module "FSSH1"     (component FSShell)
   - FSSH1_PrintPrompt -Prints the prompt to the stdOut channel
   - FSSH1_SendNum8u -Sends an 8bit unsigned number to the given I/O
   - FSSH1_SendNum8s -Sends an 8bit signed number to the given I/O
   - FSSH1_SendNum16u -Sends a 16bit unsigned number to the given I/O
   - FSSH1_SendNum16s -Sends a 16bit signed number to the given I/O
   - FSSH1_SendNum32u -Sends a 32bit unsigned number to the given I/O
   - FSSH1_SendNum32s -Sends a 32bit signed number to the given I/O
   - FSSH1_SendStr -Prints a string using an I/O function
   - FSSH1_Date -Processes the date command
   - FSSH1_Time -Processes the time command
   - FSSH1_PrintStatus -Prints various available system status information
   - FSSH1_ShellCmd -Parses a shell command. Use 'help' to get a list of supported commands.
   - FSSH1_ReadLine -Reads a line from stdIn and returns TRUE if we have a line, FALSE otherwise.
   - FSSH1_PrintCommandFailed -Prints a standard message for failed or unknown commands
   - FSSH1_ParseCommand -Parses a shell command. It handles first the internal commands and will call the provided callback.
   - FSSH1_GetStdio -Returns the default stdio channel. This method is only available if a shell is enabled in the component 
                properties.
   - FSSH1_ReadAndParseLine -Reads characters from the default input channel and appends it to the buffer. Once a new line has 
                been detected, the line will be parsed.
   - FSSH1_RequestSerial -Used to get mutual access to the shell console. Only has an effect if using an RTOS with semaphore 
                for the console access.
   - FSSH1_ReleaseSerial -Used to release mutual access to the shell console. Only has an effect if using an RTOS with 
                semaphore for the console access.
   - FSSH1_GetSemaphore -Return the semaphore of the shell.
   - FSSH1_SendStatusStr -Prints a status string using an I/O function, formated for the 'status' command
   - FSSH1_SendHelpStr -Prints a string using an I/O function, formated for the 'help' command
   - FSSH1_ReadChar -Reads a character (blocking)
   - FSSH1_SendChar -Sends a character (blocking)
   - FSSH1_KeyPressed -Checks if a key has been pressed (a character is present in the input buffer)
   - FSSH1_Init -Initializes the module, especially creates the mutex semaphore if an RTOS is used.
   - FSSH1_Deinit -De-Initializes the module, especially frees the mutex semaphore if an RTOS is used.

Module "AS1"       (component Serial_LDD)
   - AS1_Init -Initializes the device. Allocates memory for the device data structure, allocates interrupt vectors and sets 
                interrupt priority, sets pin routing, sets timing, etc. If the "Enable in init. code" is set to "yes" value 
                then the device is also enabled(see the description of the Enable() method). In this case the Enable() method 
                is not necessary and needn't to be generated.
   - AS1_Deinit -Deinitializes the device. Switches off the device, frees the device data structure memory, interrupts vectors, 
                etc.
   - AS1_SendBlock -Sends a block of characters. The method returns ERR_BUSY when the previous block transmission is not 
                completed. Method <CancelBlockTransmission> can be used to cancel a transmit operation. This method is 
                available only if the transmitter property is enabled.
   - AS1_ReceiveBlock -Specifies the number of data to receive. The method returns ERR_BUSY until the specified number of 
                characters is received. Method <CancelBlockReception> can be used to cancel a running receive operation.
   - AS1_GetSentDataNum -Returns the number of sent characters.
   - AS1_GetReceivedDataNum -Returns the number of received characters in the receive buffer.

Module "TMOUT1"    (component Timeout)
   - TMOUT1_GetCounter -Initializes a new timeout counter and returns the handle to it. At the end, use LeaveCounter() to free 
                up the ressource.
   - TMOUT1_LeaveCounter -To be called to return the counter. Note that a counter always should be returned so it can be reused.
   - TMOUT1_Value -Return the current value of the counter (in ticks)
   - TMOUT1_CounterExpired -Returns true if the timeout counter has been expired
   - TMOUT1_AddTick -Method to be called from a priodic timer or interrupt. It will decrement all current counters by one down 
                to zero.
   - TMOUT1_Init -Initialization of the driver

Module "TU1"       (component TimerUnit_LDD)
   - TU1_Init -Initializes the device. Allocates memory for the device data structure, allocates interrupt vectors and sets 
                interrupt priority, sets pin routing, sets timing, etc. If the property <"Enable in init. code"> is set to 
                "yes" value then the device is also enabled (see the description of the <Enable> method). In this case the 
                <Enable> method is not necessary and needn't to be generated. This method can be called only once. Before the 
                second call of Init the <Deinit> must be called first.
   - TU1_Deinit -Deinitializes the device. Switches off the device, frees the device data structure memory, interrupts vectors, 
                etc.
   - TU1_Enable -Enables the component - it starts the signal generation. Events may be generated (see SetEventMask). The 
                method is not available if the counter can't be disabled/enabled by HW.
   - TU1_Disable -Disables the component - it stops signal generation and events calling. The method is not available if the 
                counter can't be disabled/enabled by HW.
   - TU1_GetPeriodTicks -Returns the number of counter ticks before re-initialization. See also method <SetPeriodTicks>. This 
                method is available only if the property <"Counter restart"> is switched to 'on-match' value.
   - TU1_ResetCounter -Resets counter. If counter is counting up then it is set to zero. If counter is counting down then 
                counter is updated to the reload value.   The method is not available if HW doesn't allow resetting of the 
                counter.
   - TU1_GetCounterValue -Returns the content of counter register. This method can be used both if counter is enabled and if 
                counter is disabled. The method is not available if HW doesn't allow reading of the counter.
   - TU1_SetOffsetTicks -Sets the new offset value to channel specified by the parameter ChannelIdx. It is user responsibility 
                to use value below selected period. This method is available when at least one channel is configured.
   - TU1_GetOffsetTicks -Returns the number of counter ticks to compare match channel specified by the parameter ChannelIdx. 
                See also method <SetOffsetTicks>. This method is available when at least one channel is configured.
   - TU1_SelectOutputAction -Sets the type of compare match and counter overflow action on channel output. This method is 
                available when at least one channel is configured.

Module "TU3"       (component TimerUnit_LDD)
   - TU3_Init -Initializes the device. Allocates memory for the device data structure, allocates interrupt vectors and sets 
                interrupt priority, sets pin routing, sets timing, etc. If the property <"Enable in init. code"> is set to 
                "yes" value then the device is also enabled (see the description of the <Enable> method). In this case the 
                <Enable> method is not necessary and needn't to be generated. This method can be called only once. Before the 
                second call of Init the <Deinit> must be called first.
   - TU3_Deinit -Deinitializes the device. Switches off the device, frees the device data structure memory, interrupts vectors, 
                etc.
   - TU3_Enable -Enables the component - it starts the signal generation. Events may be generated (see SetEventMask). The 
                method is not available if the counter can't be disabled/enabled by HW.
   - TU3_Disable -Disables the component - it stops signal generation and events calling. The method is not available if the 
                counter can't be disabled/enabled by HW.
   - TU3_GetPeriodTicks -Returns the number of counter ticks before re-initialization. See also method <SetPeriodTicks>. This 
                method is available only if the property <"Counter restart"> is switched to 'on-match' value.
   - TU3_ResetCounter -Resets counter. If counter is counting up then it is set to zero. If counter is counting down then 
                counter is updated to the reload value.   The method is not available if HW doesn't allow resetting of the 
                counter.
   - TU3_GetCounterValue -Returns the content of counter register. This method can be used both if counter is enabled and if 
                counter is disabled. The method is not available if HW doesn't allow reading of the counter.
   - TU3_SetOffsetTicks -Sets the new offset value to channel specified by the parameter ChannelIdx. It is user responsibility 
                to use value below selected period. This method is available when at least one channel is configured.
   - TU3_GetOffsetTicks -Returns the number of counter ticks to compare match channel specified by the parameter ChannelIdx. 
                See also method <SetOffsetTicks>. This method is available when at least one channel is configured.
   - TU3_SelectOutputAction -Sets the type of compare match and counter overflow action on channel output. This method is 
                available when at least one channel is configured.

Module "Cpu"       (component MKL25Z128LK4)

===================================================================================
